name: Build AMI after merge

# ðŸ‘‰ ONLY runs after a PR into main is CLOSED
on:
  pull_request:
    types: [closed]
    branches: [ main ]

permissions:
  contents: read

jobs:
   test-and-package:
    name: Run tests â†’ build artifact
    runs-on: ubuntu-latest
    timeout-minutes: 60

    if: github.event.pull_request.merged == true

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_DB: webapp
          POSTGRES_USER: csye_app
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U csye_app -d webapp"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Guard so we fail early if DB_PASSWORD is missing
      - name: Ensure DB_PASSWORD secret exists (guard)
        run: |
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "ERROR: DB_PASSWORD secret is empty or not set IN THIS REPO."
            exit 1
          fi
          echo "DB_PASSWORD is set (value hidden)."

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install psql client
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client netcat-openbsd

      - name: Wait for Postgres port
        run: |
          for i in {1..30}; do
            nc -z localhost 5432 && echo "Postgres up" && exit 0
            echo "Waiting for Postgres... ($i)"
            sleep 2
          done
          echo "Postgres did not start in time" >&2
          exit 1

      - name: Initialize database schema
        env:
          PGPASSWORD: postgres
        run: |
          echo "Initializing DB from ./sql/schema.sql ..."
          test -f sql/schema.sql || { echo "sql/schema.sql not found"; ls -R; exit 1; }
          psql -h localhost -U csye_app -d webapp -f sql/schema.sql
          echo "âœ… Schema loaded"

      - name: Verify tables (debug)
        env:
          PGPASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          psql -h localhost -U csye_app -d webapp -c '\dt' || true

      - name: Install & test
        env:
          PGHOST: localhost
          PGUSER: csye_app
          PGPASSWORD: postgres
          PGDATABASE: webapp
          PGPORT: 5432
          NODE_ENV: test
        run: |
          npm ci
          npm test 

      # Build runtime artifact for /opt/webapp
      - name: Build artifact (zip)
        run: |
          mkdir -p dist
          zip -r dist/artifact.zip src package*.json

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: webapp-artifact
          path: dist/artifact.zip

   build-and-deploy:
    name: Build AMI (DEV) â†’ Share to DEMO â†’ Instance refresh
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: test-and-package

    # âœ… only run when PR is merged
    if: github.event.pull_request.merged == true


    env:
      # ASG name from your Terraform (demo account)
      ASG_NAME: "csye6225_asg"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---------- DEV: Build AMI with Packer 
      - name: Configure AWS credentials (DEV)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}      # DEV
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}  # DEV
          aws-region:            ${{ secrets.AWS_REGION }}             # DEV (e.g., us-east-1)

      - name: Setup Packer
        uses: hashicorp/setup-packer@v2
        with:
          version: '1.14.2'

      - name: Download app artifact for Packer
        uses: actions/download-artifact@v4
        with:
          name: webapp-artifact
          path: packer/dist

      - name: packer init
        working-directory: packer
        run: packer init .

      - name: Sanity-check inputs for Packer
        run: |
          set -e
          test -f packer/dist/artifact.zip || { echo "artifact.zip missing at packer/dist"; ls -R packer; exit 1; }
          [[ "${{ secrets.DEMO_ACCOUNT_ID }}" =~ ^[0-9]{12}$ ]] || { echo "DEMO_ACCOUNT_ID must be 12 digits"; exit 1; }
          [[ -n "${{ secrets.AWS_REGION }}" ]] || { echo "AWS_REGION missing"; exit 1; }
          [[ -n "${{ secrets.DB_PASSWORD }}" ]] || { echo "DB_PASSWORD missing"; exit 1; }

      - name: Show AWS identity and default VPC (DEV)
        run: |
          aws sts get-caller-identity
          echo "Region: $(aws configure get region)"
          echo "Default VPC in region:"
          aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[].VpcId' --output text || true

      # ðŸ§± Build AMI in DEV and capture AMI ID
      - name: packer build (AMI in DEV)
        id: packer-build
        working-directory: packer
        env:
          PACKER_LOG: "1"
        run: |
          set -e
          mkdir -p ../_logs
          packer build -machine-readable -color=false \
            -var "region=${{ secrets.AWS_REGION }}" \
            -var "demo_account_id=${{ secrets.DEMO_ACCOUNT_ID }}" \
            -var "app_port=${{ secrets.APP_PORT || 8080 }}" \
            -var "db_password=${{ secrets.DB_PASSWORD }}" \
            ubuntu-webapp.pkr.hcl | tee ../_logs/packer-build.log

          AMI_LINE=$(grep 'artifact,0,id' ../_logs/packer-build.log | tail -n 1 || true)
          if [ -z "$AMI_LINE" ]; then
            echo "AMI id not found in packer output"; exit 1
          fi

          # machine-readable: ...,artifact,0,id,us-east-1:ami-0123456789abcdef0
          AMI_ID=$(echo "$AMI_LINE" | cut -d',' -f6 | cut -d':' -f2)
          echo "Built AMI_ID=$AMI_ID"
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT

      - name: Upload packer build log
        uses: actions/upload-artifact@v4
        with:
          name: packer-build-log
          path: _logs/packer-build.log

      # Explicitly share AMI with DEMO (even if template also does it)
      - name: Share AMI with DEMO account
        run: |
          AMI_ID="${{ steps.packer-build.outputs.ami_id }}"
          DEMO_ACCOUNT="${{ secrets.DEMO_ACCOUNT_ID }}"
          echo "Sharing AMI $AMI_ID with demo account $DEMO_ACCOUNT"
          aws ec2 modify-image-attribute \
            --image-id "$AMI_ID" \
            --launch-permission "Add=[{UserId=$DEMO_ACCOUNT}]"

      # ---------- DEMO: Update LT + instance refresh ----------
      - name: Configure AWS credentials (DEMO)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.DEMO_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEMO_AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.DEMO_AWS_REGION }}

      - name: Update Launch Template and start instance refresh (DEMO)
        id: refresh
        run: |
          AMI_ID="${{ steps.packer-build.outputs.ami_id }}"
          ASG_NAME="${{ env.ASG_NAME }}"

          echo "Using AMI $AMI_ID for ASG $ASG_NAME in DEMO"

          # Find Launch Template attached to ASG
          LT_ID=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query 'AutoScalingGroups[0].LaunchTemplate.LaunchTemplateId' \
            --output text)

          if [ -z "$LT_ID" ] || [ "$LT_ID" = "None" ]; then
            echo "Could not find LaunchTemplateId for ASG $ASG_NAME"
            exit 1
          fi

          echo "Launch Template ID: $LT_ID"

          # Create new Launch Template version using new AMI
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id "$LT_ID" \
            --source-version '$Latest' \
            --launch-template-data "{\"ImageId\":\"$AMI_ID\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)

          echo "New Launch Template version: $NEW_VERSION"

          # Point ASG at the new version
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "$ASG_NAME" \
            --launch-template "LaunchTemplateId=$LT_ID,Version=$NEW_VERSION"

          # Start instance refresh
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "$ASG_NAME" \
            --strategy Rolling \
            --query 'InstanceRefreshId' \
            --output text)

          echo "REFRESH_ID=$REFRESH_ID"
          echo "refresh_id=$REFRESH_ID" >> $GITHUB_OUTPUT

      - name: Wait for instance refresh (DEMO)
        run: |
          ASG_NAME="${{ env.ASG_NAME }}"
          REFRESH_ID="${{ steps.refresh.outputs.refresh_id }}"

          echo "Waiting for instance refresh $REFRESH_ID on ASG $ASG_NAME"

          # Poll every 30s up to ~30 minutes
          for i in {1..60}; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "$ASG_NAME" \
              --instance-refresh-ids "$REFRESH_ID" \
              --query 'InstanceRefreshes[0].Status' \
              --output text)

            echo "Status: $STATUS"

            if [ "$STATUS" = "Successful" ]; then
              echo "Instance refresh succeeded"
              exit 0
            fi

            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "Instance refresh failed with status $STATUS"
              exit 1
            fi

            sleep 30
          done

          echo "Timed out waiting for instance refresh"
          exit 1
